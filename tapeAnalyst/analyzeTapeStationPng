#!/usr/bin/env python

# Built-in
import argparse

# 3rd Party
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from skimage import io, color

# tapeAnalyst
import tapeAnalyst.reporting as reporting

def getOptions():
    """ Function to pull in command line arguments. """
    parser = argparse.ArgumentParser(description='A tool to analyze image output from the Agilent Tape Station 2200.')
    parser.add_argument('-i', '--input', dest='fname', action='store', required=True, help='A PNG file containing the gel output from the TapeStations 2200.')

    args = parser.parse_args(['-i', '../data/JH_2.png'])
    return args

def dyeMarker(image, dye='front'):
    """ Set boolean mask on gel image to easily identify dye front or dye end. 

    The TapeStation annotates the dye front as green and the dye end as purple.
    Using these color profiles, mask the remainder of the image to be white.

    :Args:
        :param image: gel image to be analyzed.
        :type image: numpy.ndarray
        :param dye: Name of the dye you want to locate {'front', 'end'}
        :type dye: str
        
    :returns: Masked array

    """
    if dye == 'front':
        # Green
        maskR = image[:, :, 0] < 10
        maskG = image[:, :, 1] > 10
        maskB = image[:, :, 3] > 10
    elif dye == 'end':
        # Purple
        maskR = image[:, :, 0] > 10
        maskG = image[:, :, 1] < 10
        maskB = image[:, :, 3] > 10
    else:
        print("dye must be 'front' or 'end'")
        raise ValueError
    
    # Set everything that is not in my mask to 0
    image2 = image.copy()
    image2[~maskR] = 0
    image2[~maskG] = 0
    image2[~maskB] = 0

    return image2

def consecutive(arr, stepsize=1):
    """ Identify the location of consecutively numbered parts of an array.

    Found this solution at:
    http://stackoverflow.com/questions/7352684/how-to-find-the-groups-of-consecutive-elements-from-an-array-in-numpy 

    :Args:
        :param arr: 1D array
        :type arr: numpy.array
        :param stepsize: The distance you want to require between groups
        :type stepsize: int

    :returns: a list of numpy.arrays grouping consecutive number together
    :rtype: list of numpy.arrays

    """
    return np.split(arr, np.where(np.diff(arr) != stepsize)[0]+1)

def getWellLocations(arr):
    """ Take a dye array and figure out where wells are located.

    :Args:
        :param arr: A dye array (dyeEnd)

    :returns: A list of tuples with (start, end, well width, midpoint of the well)
    :rtype: list of tuples

    """
    # Group consecutive pixels (aka wells)
    wells = consecutive(arr)

    # Iterate over pixel groups and pull out the boundries of the well and the
    # midpoint
    coords = list()
    for well in wells:
        start = well[0]
        end = well[-1]
        width = end - start
        midpoint = int(np.ceil(width / 2 + start))
        coords.append((start, end, width, midpoint))

    return coords

def getIntensities(gel, wells):
    """ Get column vector of intensity values.

    From each well pull the mean intensity.

    :Args:
        :param gel: Gel to get intensity values from.
        :type gel: numpy.ndarray (n, m) does not work on 3D arrays like RGB
                   images.
        :param wells: List of well information
        :type wells: list of tuples

    :returns: A list of column vectors of intensity.
    :rtype: list of numpy.ndarray

    """
    intensities = list()
    for well in wells:
        start = well[0]
        end = well[1]
        midpoint = well[3]
        col = gel[:, start:end]
        mean = np.mean(col, axis=1)
        intensities.append(mean)

    return intensities


def main(args):
    """ """
    # read gel image
    gel = io.imread(args.fname)

    # Figure out the top and bottom coordinates of gel using the dye
    ## Get coords for dye front
    dyeFrontGel = dyeMarker(gel, dye='front')
    dyeFrontCoords = np.nonzero(dyeFrontGel[:, :, 1].sum(axis=1))[0]
    dyeFrontBottom = dyeFrontCoords[-1]

    ## Get coords for dye end
    dyeEndGel = dyeMarker(gel, dye='end')
    dyeEndCoords = np.nonzero(dyeEndGel[:, :, 0].sum(axis=1))[0]
    dyeEndTop = dyeEndCoords[0]

    # Locate wells using dye end
    dyeEndWells = np.nonzero(dyeEndGel[:, :, 0].sum(axis=0))[0]
    wells = getWellLocations(dyeEndWells)

    # Convert gel to gray scale for intensity analysis
    greyGel = 1 - color.rgb2grey(gel)

    # Iterate over wells and get the column vector of grey scale values
    intensity = getIntensities(greyGel, wells)


    fig, (g, h) = plt.subplots(1, 2, figsize=(20, 20))
    g.imshow(greyGel, cmap='Greys')
    h.plot(intensity[-1])

    html_out = reporting.build_report(fig)
    with open('/home/jfear/devel/bob.html', 'w') as OUT:
        OUT.write(html_out)



if __name__ == '__main__':

    args = getOptions()

    main(args)
